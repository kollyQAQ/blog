[TOC]

## * 和 & 的区别 

1. & 是取地址符号，即取得某个变量的地址，如；&a
2. \* 是指针运算符，可以表示一个变量是指针类型，也可以表示一个指针变量所指向的存储单元，也就是这个地址所存储的值 .

经常会见到: p . *p , &p 三个符号 
p 是一个指针变量的名字，表示此指针变量指向的内存地址，如果使用 % p 来输出的话，它将是一个 16 进制数。而 * p 表示此指针指向的内存地址中存放的内容，一般是一个和指针类型一致的变量或者常量。 
而我们知道，& 是取地址运算符，&p 就是取指针 p 的地址。等会，怎么又来了个地址，它到底和 p 有什么区别？区别在于，指针 p 同时也是个变量，既然是变量，编译器肯定要为其分配内存地址，就像程序中定义了一个 int 型的变量 i，编译器要为其分配一块内存空间一样。而 & p 就表示编译器为变量 p 分配的内存地址，而因为 p 是一个指针变量，这种特殊的身份注定了它要指向另外一个内存地址，程序员按照程序的需要让它指向一个内存地址，这个它指向的内存地址就用 p 表示。而且，p 指向的地址中的内容就用 * p 表示
————————————————
版权声明：本文为CSDN博主「梅老板000」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/sybnfkn040601/article/details/54614798

## 数据类型

#### 值类型

基础数据类型(int、float、bool和string)、数组类型(array)、结构体类型(struct)

#### 引用类型

切片类型(slice)、通道类型(chan)、函数类型(func)、接口类型(interface)

> 引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本

很多文章说 map 是引用类型，事实上，map 并不是引用类型，而是一个指针 *hmap

[If a map isn’t a reference variable, what is it?](https://dave.cheney.net/2017/04/30/if-a-map-isnt-a-reference-variable-what-is-it)

#### 自定义类型

Go语言支持我们自定义类型，比如刚刚上面的结构体类型，就是我们自定义的类型，这也是比较常用的自定义类型的方法。

另外一个自定义类型的方法是基于一个已有的类型，就是基于一个现有的类型创造新的类型，这种也是使用`type`关键字。

```go
type Duration int64
```

我们在使用`time`这个包的时候，对于类型`time.Duration`应该非常熟悉，它其实就是基于`int64` 这个基本类型创建的新类型，来表示时间的间隔。

但是这里我们注意，虽然`Duration`是基于`int64`创建，觉得他们其实一样，比如都可以使用数字赋值。

```go
type Duration int64

var i Duration = 100
var j int64 = 100
```

但是本质上，他们并不是同一种类型，所以对于Go这种强类型语言，他们是不能相互赋值的。

```go
type Duration int64

var dur Duration
dur=int64(100)
fmt.Println(dur)
```

上面的例子，在编译的时候，会报类型转换的异常错误。

```bash
cannot use int64(100) (type int64) as type Duration in assignment
```

Go的编译器不会像Java的那样，帮我们做隐式的类型转换。

有时候，大家会迷茫，已经有了`int64`这些类型了，可以表示，还要基于他们创建新的类型做什么？其实这就是Go灵活的地方，我们可以使用自定义的类型做很多事情，比如添加方法，比如可以更明确的表示业务的含义等等，下一篇方法我们会讲到。



## 包的 init 函数

每个包都可以有任意多个init函数，这些init函数都会在main函数之前执行。init函数通常用来做初始化变量、设置包或者其他需要在程序执行前的引导工作。比如上面我们讲的需要使用`_`空标志符来导入一个包的目的，就是想执行这个包里的init函数。



## 函数的闭包

Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量 “绑定” 在一起。

例如，函数 `adder` 返回一个闭包。每个闭包都被绑定在其各自的 `sum` 变量上。

```go
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
```

```
0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90
```



## 类型选择

**类型选择** 是一种按顺序从几个类型断言中选择分支的结构。

类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。

```
switch v := i.(type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
}
```

类型选择中的声明与类型断言 `i.(T)` 的语法相同，只是具体类型 `T` 被替换成了关键字 `type`。

此选择语句判断接口值 `i` 保存的值类型是 `T` 还是 `S`。在 `T` 或 `S` 的情况下，变量 `v` 会分别按 `T` 或 `S` 类型保存 `i` 拥有的值。在默认（即没有匹配）的情况下，变量 `v` 与 `i` 的接口类型和值相同。

```go
package main

import "fmt"

func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Twice %v is %v\n", v, v*2)
	case string:
		fmt.Printf("%q is %v bytes long\n", v, len(v))
	default:
		fmt.Printf("I don't know about type %T!\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}
```

```
Twice 21 is 42
"hello" is 5 bytes long
I don't know about type bool!
```



