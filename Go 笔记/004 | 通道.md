[TOC]

## 概述

作为 Go 语言最有特殊的数据类型，通道（channel）完成可以与 goroutine 并驾齐驱，共同代表 Go 语言独有的并发编程模式和编程哲学。

> Don't communicate by sharing memory; share memory by communicating. (不要通过共享内存来通信，而应该通过通信来共享内存。)

通道类型的值本身就是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。



### 创建通道

```go
ch1 := make(chan int) // 不带缓冲的通道
ch2 := make(chan string, 10) //带缓冲的通道，Buffered Channel
```

一个通道相当于一个 FIFO 的队列，先被发送进通道的值一定会先被接收。

### 发送&接收数据

通过通道操作符 `<-` 来发送或者接收值。（“箭头” 就是数据流的方向。）

```
ch <- v    // 将 v 发送至信道 ch。
v := <-ch  // 从 ch 接收值并赋予 v。
```

默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。

```go
package concurrency

import (
	"fmt"
	"testing"
	"time"
)

func service() string {
	time.Sleep(time.Millisecond * 50)
	return "Done"
}

func otherTask() {
	fmt.Println("working on something else")
	time.Sleep(time.Millisecond * 100)
	fmt.Println("Task is done.")
}

func AsyncService() chan string {
	// retCh := make(chan string)
	retCh := make(chan string, 1)
	go func() {
		ret := service()
		fmt.Println("returned result.")
		retCh <- ret
		fmt.Println("service exited.")
	}()
	return retCh
}

func TestAsynService(t *testing.T) {
	retCh := AsyncService()
	otherTask()
	fmt.Println(<-retCh)
	time.Sleep(time.Second * 1)
}
```

```
=== RUN   TestAsynService
working on something else
returned result.
service exited.
Task is done.
Done
--- PASS: TestAsynService (1.11s)
PASS
```

以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。

```go
package main

import "fmt"

func sum(s []int, c chan int) {
	sum := 0
	for _, v := range s {
		sum += v
	}
	c <- sum // 将和送入 c
}

func main() {
	s := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int)
	go sum(s[:len(s)/2], c)
	go sum(s[len(s)/2:], c)
	x, y := <-c, <-c // 从 c 中接收

	fmt.Println(x, y, x+y)
}
```

### 多路选择和超时控制 / select、case

#### 多路选择

```go
select{
  case ret := <- retCh1:
  	t.Logf("result %s", ret)
  case ret := <- retCh2:
  	t.Logf("result %s", ret)
  default:
  	t.Error("No one retured")
}
```

#### 超时控制

```go
select {
	case ret := <-retCh:
		t.Logf("result %s", ret)
	case <-time.After(time.second * 1):
		t.Error("time out")
}
```

#### 超时示例

```go
package select_test

import (
	"fmt"
	"testing"
	"time"
)

func service() string {
	time.Sleep(time.Millisecond * 500)
	return "Done"
}

func AsyncService() chan string {
	retCh := make(chan string, 1)
	go func() {
		ret := service()
		fmt.Println("returned result.")
		retCh <- ret
		fmt.Println("service exited.")
	}()
	return retCh
}

func TestSelect(t *testing.T) {
	select {
	case ret := <-AsyncService():
		t.Log(ret)
	case <-time.After(time.Millisecond * 100):
		t.Error("time out")
	}
}
```

```
=== RUN   TestSelect
--- FAIL: TestSelect (0.10s)
    select_test.go:31: time out
FAIL
```

### 通道的关闭

- 向关闭的 channel 发送数据，会导致 panic
- v，ok <- ch; ok 为 bool 值，true 表示正常接收，false 表示通道关闭
- 所有的 channel 接收者都会在 channel 关闭时，立刻从阻塞等待中返回且上述 ok 值为 false。这个广播机制常被利用，进行向多个订阅者同时发送信号。如：退出信号

```go
package channel_close

import (
	"fmt"
	"sync"
	"testing"
)

func dataProducer(ch chan int, wg *sync.WaitGroup) {
	go func() {
		for i := 0; i < 10; i++ {
			ch <- i
		}
		close(ch) // 关闭通道
		wg.Done()
	}()

}

func dataReceiver(ch chan int, wg *sync.WaitGroup) {
	go func() {
		for {
			if data, ok := <-ch; ok {
				fmt.Println(data)
			} else {
				break
			}
		}
		wg.Done()
	}()

}

func TestCloseChannel(t *testing.T) {
	var wg sync.WaitGroup
	ch := make(chan int)
	wg.Add(1)
	dataProducer(ch, &wg)
	wg.Add(1)
	dataReceiver(ch, &wg)
	wg.Add(1)
	dataReceiver(ch, &wg) // 启动多个 receiver
	wg.Wait()

}
```

```
=== RUN   TestCloseChannel
0
1
2
3
4
5
7
6
9
8
--- PASS: TestCloseChannel (0.00s)
PASS
```



#### 相关特性

- 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的
  - 元素值从外界进入通道时会被复制。也就是，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本
  - 接收操作包含两步：生成元素值的副本；放置副本给接收方；删除通道中的元素值
- 发送操作和接收操作中对元素值的处理都是不可分割的
- 发送操作在完全完成之前都会被阻塞。接收操作也是如此

#### 其他

通道的底层数据结构是环形链表