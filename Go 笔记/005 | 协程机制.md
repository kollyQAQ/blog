[TOC]

## 概述

| 概念         | 说明                                             |
| :----------- | :----------------------------------------------- |
| 进程         | 一个程序对应一个独立程序空间                     |
| 线程         | 一个执行空间，一个进程可以有多个线程             |
| 逻辑处理器   | 执行创建的 goroutine，绑定一个线程               |
| 调度器       | Go 运行时中的，分配 goroutine 给不同的逻辑处理器 |
| 全局运行队列 | 所有刚创建的 goroutine 都会放到这里              |
| 本地运行队列 | 逻辑处理器的 goroutine 队列                      |

当我们创建一个 goroutine 的后，会先存放在`全局运行队列`中，等待 Go 运行时的`调度器`进行调度，把他们分配给其中的一个`逻辑处理器`，并放到这个逻辑处理器对应的`本地运行队列`中，最终等着被`逻辑处理器`执行即可。

这一套管理、调度、执行 goroutine 的方式称之为 Go 的并发。并发可以同时做很多事情，比如有个 goroutine 执行了一半，就被暂停执行其他 goroutine 去了，这是 Go 控制管理的。所以并发的概念和并行不一样，并行指的是在不同的物理处理器上同时执行不同的代码片段，**并行可以同时做很多事情，而并发是同时管理很多事情**，因为操作系统和硬件的总资源比较少，所以并发的效果要比并行好的多，使用较少的资源做更多的事情，也是 Go 语言提倡的。

## Go 并发

Go 的并发原理我们刚刚讲了，那么 Go 的并行是怎样的呢？其实答案非常简单，多创建一个`逻辑处理器`就好了，这样调度器就可以同时分配`全局运行队列`中的 goroutine 到不同的`逻辑处理器`上并行执行。

```go
func main() {
	var wg sync.WaitGroup
	wg.Add(2)
	go func(){
		defer wg.Done()
		for i:=1;i<100;i++ {
			fmt.Println("A:",i)
		}
	}()
	go func(){
		defer wg.Done()
		for i:=1;i<100;i++ {
			fmt.Println("B:",i)
		}
	}()
	wg.Wait()
}
```

这是一个简单的并发程序。创建一个 goroutine 是通过 `go` 关键字的，其后跟一个函数或者方法即可。

这里的 `sync.WaitGroup` 其实是一个计数的信号量，使用它的目的是要 `main` 函数等待两个 goroutine 执行完成后再结束，不然这两个 `goroutine` 还在运行的时候，程序就结束了，看不到想要的结果。

`sync.WaitGroup` 的使用也非常简单，先是使用 `Add` 方法设设置计算器为 2，每一个 goroutine 的函数执行完之后，就调用 `Done` 方法减 1。`Wait` 方法的意思是如果计数器大于 0，就会阻塞，所以 `main` 函数会一直等待 2 个 goroutine 完成后，再结束。



我们运行这个程序，会发现 A 和 B 前缀会交叉出现，并且每次运行的结果可能不一样，这就是 Go 调度器调度的结果。

**默认情况下，Go 默认是给每个可用的物理处理器都分配一个逻辑处理器**，因为我的电脑是 4 核的，所以上面的例子默认创建了 4 个逻辑处理器，所以这个例子中同时也有并行的调度，如果我们强制只使用一个逻辑处理器，我们再看看结果。

```go
func main() {
	runtime.GOMAXPROCS(1)
	var wg sync.WaitGroup
	wg.Add(2)
	go func(){
		defer wg.Done()
		for i:=1;i<100;i++ {
			fmt.Println("A:",i)
		}
	}()
	go func(){
		defer wg.Done()
		for i:=1;i<100;i++ {
			fmt.Println("B:",i)
		}
	}()
	wg.Wait()
}
```

设置逻辑处理器个数也非常简单，在程序开头使用 `runtime.GOMAXPROCS(1)` 即可，这里设置的数量是 1。我们这时候再运行，会发现先打印 A，再打印 B。

这里我们不要误认为是顺序执行，这里之所以顺序输出的原因，是因为我们的 goroutine 执行时间太短暂了，还没来得及切换到第 2 个 goroutine，第 1 个 goroutine 就完成了。这里我们可以把每个 goroutine 的执行时间拉长一些，就可以看到并发的效果了，这里不再示例了，大家自己试试。



对于逻辑处理器的个数，不是越多越好，要根据电脑的实际物理核数，如果不是多核的，设置再多的逻辑处理器个数也没用，如果需要设置的话，一般我们采用如下代码设置。

```go
runtime.GOMAXPROCS(runtime.NumCPU())
```

所以对于并发来说，就是 Go 语言本身自己实现的调度，对于并行来说，是和运行的电脑的物理处理器的核数有关的，多核就可以并行并发，单核只能并发了。