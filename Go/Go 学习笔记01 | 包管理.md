[TOC]

## 包的init函数

每个包都可以有任意多个 init 函数，这些 init 函数都会在 main 函数之前执行。init 函数通常用来做初始化变量、设置包或者其他需要在程序执行前的引导工作。比如上面我们讲的需要使用_空标志符来导入一个包的目的，就是想执行这个包里的 init 函数。

我们以数据库的驱动为例，Go 语言为了统一关于数据库的访问，使用 databases/sql 抽象了一层数据库的操作，可以满足我们操作 MYSQL、Postgre 等数据库，这样不管我们使用这些数据库的哪个驱动，编码操作都是一样的，想换驱动的时候，就可以直接换掉，而不用修改具体的代码。

这些数据库驱动的实现，就是具体的，可以由任何人实现的，它的原理就是定义了 init 函数，在程序运行之前，把实现好的驱动注册到 sql 包里，这样我们就使用使用它操作数据库了。

```go
package mysql


import (
        "database/sql"
)


func init() {
        sql.Register("mysql", &MySQLDriver{})
}
```

因为我们只是想执行这个 mysql 包的 init 方法，并不想使用这个包，所以我们在导入这个包的时候，需要使用_重命名包名，避免编译错误。

```go
import "database/sql"
import _ "github.com/go-sql-driver/mysql"


db, err := sql.Open("mysql", "user:password@/dbname")
```

看非常简洁，剩下针对的数据库的操作，都是使用的 database/sql 标准接口，如果我们想换一个 mysql 的驱动的话，只需要换个导入就可以了，灵活方便，这也是面向接口编程的便利。



# Go Module

## Module 的定义

官方给 module 的定义是：`A module is a collection of related Go packages that are versioned together as a single unit.`，定义非常晰，一组 package 的集合，一起被标记版本，即是一个 module。

通常而言，一个仓库包含一个 module（虽然也可以包含多个，但不推荐），所以仓库、module 和 package 的关系如下：

- 一个仓库包含一个或多个 Go module；
- 每个 Go module 包含一个或多个 Go package；
- 每个 package 包含一个或多个 Go 源文件；

## 语义化版本规范

语义化版本（Semantic Versioning）已成为事实上的标准，几乎知名的开源项目都遵循该规范，更详细的信息请前往 https://semver.org/ 查看，在此只提炼一些要点，以便于后续的阅读。

版本格式`v(major).(minor).(patch)`中 major 指的是大版本，minor 指小版本，patch 指补丁版本。

- major: 当发生不兼容的改动时才可以增加 major 版本；比如`v2.x.y`与`v1.x.y`是不兼容的；
- minor: 当有新增特性时才可以增加该版本，比如`v1.17.0`是在`v1.16.0`基础上加了新的特性，同时兼容`v1.16.0`；
- patch: 当有 bug 修复时才可以 增加该版本，比如`v1.17.1`修复了`v1.17.0`上的 bug，没有新特性增加；

**语义化版本规范的好处是，用户通过版本号就能了解版本信息。**

### 管理依赖

#### go get

`go get `命令可以用来分析依赖情况，并会自动下载依赖，注意：`go get` 总是获取依赖的最新版本

#### go list -m all

查看最终选定的版本

## replace 指令

顾名思义，`replace`指替换，它指示编译工具替换`require`指定中出现的包。正常工作还需要满足两个条件：

第一，`replace`仅在当前 module 为`main module`时有效，比如我们当前在编译`github.com/renhongcai/gomodule`，此时就是`main module`，如果其他项目引用了`github.com/renhongcai/gomodule`，那么其他项目编译时，`replace`就会被自动忽略。

第二，`replace`指定中`=>`前面的包及其版本号必须出现在`require`中才有效，否则指令无效，也会被忽略。 比如，上面的例子中，我们指定`replace github.com/google/uuid => github.com/google/uuid v1.1.0`，或者指定`replace github.com/google/uuid v1.0.9 => github.com/google/uuid v1.1.0`，二者均都无效。

### replace 使用场景

前面的例子中，我们使用`replace`替换`require`中的依赖，在实际项目中`replace`在项目中经常被使用，其中不乏一些精彩的用法。 但不管应用在哪种场景，其本质都一样，都是替换`require`中的依赖。

#### 替换无法下载的包

由于中国大陆网络问题，有些包无法顺利下载，比如`golang.org`组织下的包，值得庆幸的是这些包在 GitHub 都有镜像，此时 就可以使用 GitHub 上的包来替换。

比如，项目中使用了`golang.org/x/text`包：

```go
import (
    "fmt"

    "github.com/google/uuid"
    "golang.org/x/text/language"
    "golang.org/x/text/message"
)
```

没有合适的网络代理情况下，`golang.org/x/text` 很可能无法下载。那么此时，就可以使用`replace`来让我们的项目使用 GitHub 上相应的镜像包。我们可以添加一条新的`replace`条目，如下所示：

```go
replace (
    golang.org/x/text v0.3.2 => github.com/golang/text v0.3.2
)
```

此时，项目编译时就会从 GitHub 下载包。我们源代码中 import 路径 `golang.org/x/text/xxx`不需要改变。

也许有读者会问，是否可以将 import 路径由`golang.org/x/text/xxx`改成`github.com/golang/text/xxx`？这样一来，就不需要使用 replace 来替换包了。

遗憾的是，不可以。因为`github.com/golang/text`只是镜像仓库，其`go.mod`文件中定义的 module 还是`module golang.org/x/text`，这个 module 名字直接决定了你的 import 的路径。

#### 调试依赖包

有时我们需要调试依赖包，此时就可以使用`replace`来修改依赖，如下所示：

```go
replace (
	github.com/google/uuid v1.1.1 => ../uuid
	golang.org/x/text v0.3.2 => github.com/golang/text v0.3.2
)
```

语句`github.com/google/uuid v1.1.1 => ../uuid`使用本地的 uuid 来替换依赖包，此时，我们可以任意地修改`../uuid`目录的内容来进行调试。

除了使用相对路径，还可以使用绝对路径，甚至还可以使用自已的 fork 仓库。

#### 使用 fork 仓库

有时在使用开源的依赖包时发现了 bug，在开源版本还未修改或者没有新的版本发布时，你可以使用 fork 仓库，在 fork 仓库中进行 bug fix。 你可以在 fork 仓库上发布新的版本，并相应的修改`go.mod`来使用 fork 仓库。

比如，我 fork 了开源包`github.com/google/uuid`，fork 仓库地址为`github.com/RainbowMango/uuid`，那我们就可以在 fork 仓库里修改 bug 并发布新的版本`v1.1.2`，此时使用 fork 仓库的项目中`go.mod`中 replace 部分可以相应的做如下修改：

```
github.com/google/uuid v1.1.1 => github.com/RainbowMango/uuid v1.1.2
```

需要说明的是，使用 fork 仓库仅仅是临时的做法，一旦开源版本变得可用，需要尽快切换到开源版本。

#### 禁止被依赖

另一种使用`replace`的场景是你的 module 不希望被直接引用，比如开源软件 [kubernetes](https://github.com/kubernetes/kubernetes)，在它的`go.mod`中`require`部分有大量的`v0.0.0`依赖，比如：

```
module k8s.io/kubernetes


require (
    ...
    k8s.io/api v0.0.0
    k8s.io/apiextensions-apiserver v0.0.0
    k8s.io/apimachinery v0.0.0
    ...
)
```

由于上面的依赖都不存在 v0.0.0 版本，所以其他项目直接依赖`k8s.io/kubernetes`时会因无法找到版本而无法使用。 因为 Kubernetes 不希望作为 module 被直接使用，其他项目可以使用 kubernetes 其他子组件。

kubernetes 对外隐藏了依赖版本号，其真实的依赖通过`replace`指定：

```
replace (
    k8s.io/api => ./staging/src/k8s.io/api
    k8s.io/apiextensions-apiserver => ./staging/src/k8s.io/apiextensions-apiserver
    k8s.io/apimachinery => ./staging/src/k8s.io/apimachinery
)
```

前面我们说过，`replace`指令在当前模块不是`main module`时会被自动忽略的，Kubernetes 正是利用了这一特性来实现对外隐藏依赖版本号来实现禁止直接引用的目的。

## exclude 指令

`go.mod`文件中的`exclude`指令用于排除某个包的特定版本，其与`replace`类似，也仅在当前 module 为`main module`时有效，其他项目引用当前项目时，`exclude`指令会被忽略。

`exclude`指令在实际的项目中很少被使用，因为很少会显式地排除某个包的某个版本，除非我们知道某个版本有严重 bug。 比如指令`exclude github.com/google/uuid v1.1.0`，表示不使用 v1.1.0 版本。

```go
module github.com/renhongcai/gomodule

go 1.13

require (
    github.com/google/uuid v1.1.1
    github.com/renhongcai/exclude v1.0.0
    golang.org/x/text v0.3.2
)

replace golang.org/x/text v0.3.2 => github.com/golang/text v0.3.2

exclude github.com/google/uuid v1.1.0
```

## indirect 含义

在执行命令`go mod tidy`时，Go module 会自动整理`go.mod 文件`，如果有必要会在部分依赖包的后面增加`// indirect`注释。一般而言，被添加注释的包肯定是间接依赖的包，而没有添加`// indirect`注释的包则是直接依赖的包，即明确的出现在某个`import`语句中。

然而，这里需要着重强调的是：并不是所有的间接依赖都会出现在 `go.mod`文件中。

间接依赖出现在`go.mod`文件的情况，可能符合下面所列场景的一种或多种：

- 直接依赖未启用 Go module
-  直接依赖 go.mod 文件中缺失部分依赖

#### 为什么要记录间接依赖

在上面的例子中，如果某个依赖 B 没有`go.mod`文件，在 A 的`go.mod`文件中已经记录了依赖 B 及其版本号，为什么还要增加间接依赖呢？

我们知道 Go module 需要精确地记录软件的依赖情况，虽然此处记录了依赖 B 的版本号，但 B 的依赖情况没有记录下来，所以如果 B 的`go.mod`文件缺失了（或没有）这个信息，则需要在 A 的`go.mod`文件中记录下来。此时间接依赖的版本号将会根据 Go module 的版本选择机制确定一个最优版本。

#### 如何处理间接依赖

综上所述间接依赖出现在`go.mod`中，可以一定程度上说明依赖有瑕疵，要么是其不支持 Go module，要么是其`go.mod`文件不完整。

由于 Go 语言从 v1.11 版本才推出 module 的特性，众多开源软件迁移到 go module 还需要一段时间，在过渡期必然会出现间接依赖，但随着时间的推进，在`go.mod`中出现`// indirect`的机率会越来越低。

出现间接依赖可能意味着你在使用过时的软件，如果有精力的话还是推荐尽快消除间接依赖。可以通过使用依赖的新版本或者替换依赖的方式消除间接依赖。

#### 如何查找间接依赖来源(go mod why)

Go module 提供了`go mod why` 命令来解释为什么会依赖某个软件包，若要查看`go.mod`中某个间接依赖是被哪个依赖引入的，可以使用命令`go mod why -m <pkg> `来查看。

另外，命令`go mod why -m all`则可以分析所有依赖的依赖链。

Go 的多个命令行工具都有自动选择依赖版本的能力，如`go build` 和`go test`，当在源代码中增加了新的 import，这些命令将会自动选择一个最优的版本，并更新`go.mod`文件。

需要特别说明的是，如果`go.mod`文件中已标记了某个依赖包的版本号，则这些命令不会主动更新`go.mod`中的版本号。所谓自动更新版本号只在`go.mod`中缺失某些依赖或者依赖不匹配时才会发生。

## 版本选择机制

Go module 规定，如果`major`版本号大于`1`，则`major`版本号需要显式地标记在 module 名字中，如`module github.com/my/mod/v2`。这样做的好处是 Go module 会把`module github.com/my/mod/v2` 和 `module github.com/my/mod`视做两个 module，他们甚至可以被同时引用。

另外，如果 module 的版本为`v0.x.x`或`v1.x.x`则都不需要在 module 名字中体现版本号。

**这个不能算是强制性的要求，但如果不遵守该约定，后续该依赖包的使用者将会遇到各麻烦，最终有可能弃用这个不规范的依赖包**

### 最新版本选择

当在源代码中新增加了一个 import，比如：

```go
import "github.com/RainbowMango/M"
```

如果`go.mod`的 require 指令中并没有包含`github.com/RainbowMango/M`这个依赖，那么`go build` 或`go test`命令则会去`github.com/RainbowMango/M`仓库寻找最新的符合语义化版本规范的版本，比如 v1.2.3，并在`go.mod`文件中增加一条 require 依赖：

```go
require github.com/RainbowMango/M v1.2.3
```

这里，由于 import 路径里没有类似于`v2`或更高的版本号，所以版本选择时只会选择 v1.x.x 的版本，不会去选择 v2.x.x 或更高的版本。

### 最小版本选择

有时记录在`go.mod`文件中的依赖包版本会随着引入其他依赖包而发生变化。

如下图所示：

![img](https://gblobscdn.gitbook.com/assets%2F-LQm0KQP9eyG1B9ntPkR%2F-M-dT927SXokxxTHINeu%2F-M-dT9koRK8IgRUDStGC%2Fgomodule_minimal_version.png?generation=1581243740291383&alt=media)

Module A 依赖 Module M 的 v1.0.0 版本，但之后 Module A 引入了 Module D，而 Module D 依赖 Module M 的 v1.1.1 版本，此时，由于依赖的传递，Module A 也会选择 v1.1.1 版本。

需要注意的是，此时会自动选择最小可用的版本，而不是最新的 tag 版本。

## incompatible

在前面的章节中，我们介绍了 Go module 的版本选择机制，其中介绍了一个 Module 的版本号需要遵循`v..`的格式，此外，如果`major`版本号大于 1 时，其版本号还需要体现在 Module 名字中。

比如 Module `github.com/RainbowMango/m`，如果其版本号增长到`v2.x.x`时，其 Module 名字也需要相应的改变为： `github.com/RainbowMango/m/v2`。即，如果`major`版本号大于 1 时，需要在 Module 名字中体现版本。

那么如果 Module 的`major`版本号虽然变成了`v2.x.x`，但 Module 名字仍保持原样会怎么样呢？

我们还是以 Module `github.com/RainbowMango/m` 为例，假如其当前版本为`v3.6.0`，因为其 Module 名字未遵循 Golang 所推荐的风格，即 Module 名中附带版本信息，我们称这个 Module 为不规范的 Module。

不规范的 Module 还是可以引用的，但跟引用规范的 Module 略有差别。

如果我们在项目 A 中引用了该 module，使用命令`go mod tidy`，go 命令会自动查找 Module m 的最新版本，即`v3.6.0`。 由于 Module 为不规范的 Module，为了加以区分，go 命令会在`go.mod`中增加`+incompatible` 标识。



```
require (
    github.com/RainbowMango/m v3.6.0+incompatible
)
```

除了增加`+incompatible`（不兼容）标识外，在其使用上没有区别。