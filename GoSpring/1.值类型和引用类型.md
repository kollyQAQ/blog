[TOC]



什么是值类型和引用类型？ 值类型保存的是数据本身，引用类型保存的则是数据的指针(或者叫引用、地址都行)。 像 int、bool 等基础类型都是值类型，字符串也是值类型，结构体也是值类型。 假如对 int 等类型重定义并加入成员方法之后，新类型也是值类型吗？是的。换句话说，判断一个类型是值类型还是引用类型依据是它的 kind。 除了指针是引用类型之外，数组、集合、通道等也都是引用类型，这些类型都不直接保存数据，而是保存数据的地址。 由此可见，多个引用类型的对象是可以共享同一个数据的，而 Bean 指的就是这些可以被共享的数据



# Go 语言中的类型

说明什么是值类型和引用类型之前，我们先来了解 Go 语言中的类型有哪些

```go
// reflect/type.go
type Kind uint

const (
   Invalid Kind = iota
   Bool
   Int
   Int8
   Int16
   Int32
   Int64
   Uint
   Uint8
   Uint16
   Uint32
   Uint64
   Uintptr // 保存指针用的类型
   Float32
   Float64
   Complex64
   Complex128
   Array
   Chan
   Func
   Interface
   Map
   Ptr
   Slice
   String
   Struct
   UnsafePointer
)
```

**注意**：Golang 中还有个 rune 类型，它等价于 int32 类型



## 如何查看一个对象的类型

首先通过 `reflect.TypeOf` 获取对象的类型信息，然后调用 `Kind` 方法

```go
func TestGoType(t *testing.T) {
	var i int64 = 1
	println(reflect.TypeOf(i).Kind().String()) // int64

	f := func() {}
	println(reflect.TypeOf(f).Kind().String()) // func

	m := make(map[int]string)
	println(reflect.TypeOf(m).Kind().String()) // map

	st := struct { // 结构类型
		ID int
	}{}
	println(reflect.TypeOf(st).Kind().String()) // struct

	var p *int64 // 指针类型
	ptr := &i
	println(reflect.TypeOf(p).Kind().String()) // ptr
	println(reflect.TypeOf(ptr).Kind().String()) // ptr

	up := unsafe.Pointer(ptr)
	println(reflect.TypeOf(up).Kind().String()) // unsafe.Pointer，本质是 *int
}
```



# 什么是值类型和引用类型

值类型的特点是：变量直接存储值，内存通常在栈中分配

引用类型的特点是：变量存储的是一个地址，这个地址对应的空间里才是真正存储的值，内存通常在堆中分配



## 值类型

Bool、Int、Int8、Uint、Uint8、Uintptr 等其他整数类型

Float32、Float64、Complex64、Complex128

字符串 String 、数组类型 Array、结构体 Struct 

```go
func TestValueType(t *testing.T) {
   st1 := struct { // 结构体类型
      ID int
   }{1}
   st2 := st1

   st2.ID = 2
   println(st1.ID,st2.ID) // 1 2, 修改st2的内容，st1不会改变，是值类型

   arr1 :=[3]int{1,2,3} // 数组类型
   arr2 := arr1
   arr2[2]=9
   fmt.Println(arr1, arr2) // [1 2 3] [1 2 9], 修改arr2的内容，arr1不会改变，是值类型
}
```



## 引用类型

指针类型 Ptr、切片 Slice、字典Map、通道Chan、函数 Func、接口 Interface、UnsafePointer

```go
func TestReferenceType(t *testing.T) {
   sli1 :=[]int{1,2,3}
   sli2 := sli1
   sli2[2]=9
   fmt.Println(sli1, sli2) // [1 2 9] [1 2 9], 修改arr2的内容，arr1也会改变
}
```

# todo

Slice 本质是结构体，为啥结构体是值类型，Slice 是引用类型？

map 的底层结构是啥

