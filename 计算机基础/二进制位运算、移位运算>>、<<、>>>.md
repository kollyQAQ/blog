[TOC]

### Java 二进制位运算、移位运算
思考题
1、请看下面的代码段，回答 a,b,c,d,e 结果是多少？
```
public static void main(String []args){
int a=1>>2;
int b=-1>>2;
int c=1<<2;
int d=-1<<2;
int e=3>>>2;
//a,b,c,d,e 结果是多少
System.out.println("a="+a);//a=0
System.out.println("b="+b);//b=-1
System.out.println("c="+c);//c=4
System.out.println("d="+d);//d=-4
System.out.println("e="+e);//e=0
}
```
**注：">>" 代表算术右移，"<<" 代表算术左移，">>>" 代表逻辑右移**

2、请回答在 java 中，下面的表达式运算的结果是：

```
~2=?//-3
2&3=? //2
2|3=? //3
~-5=? //4
13&7=? //5
5|4=? //5
-3^3=? //-2
```
**注："~" 代表位取反，"&" 代表位与，"|" 代表位或，"^" 代表位异或 **

### 二进制基本概念
二进制是逢 2 进位的进位制，0、1 是基本算符。
现代的电子计算机技术全部采用的是二进制，因为它只使用 0、1 两个数字符号，非常简单方便，易于用电子方式实现。计算机内部处理的信息，都是采用二进制数来表示的。二进制 (Binary) 数用 0 和 1 两个数字及其组合来表示任何数。进位规则是“逢 2 进 1”，数字 1 在不同的位上代表不同的值，按从右至左的次序，这个值以二倍递增。
**注：1 个字节 = 8 位 bit**

bit 最高位是符号位如：■□□□□□□□黑色方框为符号位。
**符号位 0 代表正数，1 代表负数 **

### 二进制原码、反码、补码
对于有符号的而言：
1、二进制的最高位是符号位：0 表示正数，1 表示负数
2、正数的原码、反码、补码都一样
3、负数的反码 = 它的原码符号位不变，其它位取反
4、负数的补码 = 它的反码 + 1
5、0 的反码，补码都是 0
6、java 没有无符号数，换言之，java 中的数都是有符号的
7、在计算机运算的时候，都是以补码的方式来运算的。

### 位运算符和移位运算
java 中有 4 个位运算，分别是“按位与 &、按位或 |、按位异或 ^，按位取反~”，它们的运算规则是：
按位与 &：两位全为 1，结果为 1
按位或 |：两位有一个为 1，结果为 1
按位异或 ^：两位一个为 0，一个为 1，结果为 1
按位取反：0->1，1->0

java 中有 3 个移位运算符：
`>>`、`<<` 算术右移和算术左移，运算规则：
算术右移：低位溢出，符号位不变，并用符号位补溢出的高位
算术左移：符号位不变，低位补 0
`>>>` 逻辑右移，运算规则是：低们溢出，高位补 0


#### 计算过程举例
注意：**计算机运算的时候，都是以补码的方式来运算的，如果补码计算结果负数，则需要把补码转为原码 **
1>>2
1 的原码
00000000 00000000 00000000 00000001
因为 ** 正数的原码、反码、补码都一样 **
所以 1 的补码
00000000 00000000 00000000 00000001
算数右移 2 位结果
00000000 00000000 00000000 00000000
所以 1>>2=0
推导出 1>>n(n>1 的正整数) 结果都为 0
-1>>2
-1 的原码
10000000 00000000 00000000 00000001
-1 的反码
11111111 11111111 11111111 11111110
-1 的补码
11111111 11111111 11111111 11111111
算数右移 2 位结果
11111111 11111111 11111111 11111111
补码 ->反码 ：-1
11111111 11111111 11111111 11111110
反码 ->原码
10000000 00000000 00000000 00000001
所以 - 1>>2=-1
推导出 - 1>>n(n>1 的正整数) 结果都为 - 1

3>>>2
3 的原码
00000000 00000000 00000000 00000011
因为正数的原码、反码、补码都一样
所以 3 的补码
00000000 00000000 00000000 00000011

``>>>`` 逻辑右移 2 位结果为
00000000 00000000 00000000 00000000
所以 3>>>2=0
~2
2 的原码补码相同
2 的补码
00000000 00000000 00000000 00000010
按位取反~
11111111 11111111 11111111 11111101
因为第 1 为是 1，为负数，所以要 - 1，其它位取反得原码结果
-1
11111111 11111111 11111111 11111100
其它位取反
10000000 00000000 00000000 00000011
所以结果为 - 3

### 总结
``<<`` : 左移运算符，num << 1, 相当于 num 乘以 2
``>>``: 右移运算符，num >> 1, 相当于 num 除以 2
``>>> ``: 无符号右移，忽略符号位，空位都以 0 补齐

下面来看看这些移位运算都是怎样使用的：
```
public class Test { 
     public static void main(String[] args) {
         int number = 10;
         // 原始数二进制
         printInfo(number);
         number = number << 1;
         // 左移一位
         printInfo(number);
         number = number >> 1;
         // 右移一位
         printInfo(number);
     }
     
     /**
      * 输出一个 int 的二进制数
      * @param num
      */
     private static void printInfo(int num){
         System.out.println(Integer.toBinaryString(num));
     }
}
```
运行结果为：
```
1010
10100
1010
```
我们把上面的结果对齐一下：
```
43210      位数 --------
 1010      十进制：10     原始数         number
10100      十进制：20     左移一位       number = number << 1;
 1010      十进制：10     右移一位       number = number >> 1;
```
看了上面的 demo，现在是不是对左移和右移了解了很多了呢
对于：>>>
无符号右移，忽略符号位，空位都以 0 补齐
value >>> num -- num 指定要移位值 value 移动的位数。
**无符号右移的规则只记住一点：忽略了符号位扩展，0 补最高位 无符号右移运算符>>> 只是对 32 位和 64 位的值有意义 **