[TOC]

## 待办

那你说的业务理解能力你自己是怎么建立呢



## 自我介绍

面试官你好，我大学本科读的是软件工程专业，正式工作将近四年时间，待过两家互联网公司，第一家是做公众号服务的，我负责一些电商的后台模块的开发；现在这家是做互联网金融服务的，主要是理财和消费分期相关，我主要是负责做信贷平台的金融风控系统的建设以及一些 Java 微服务框架的维护，用户量大概两千万左右。

技术能力方面呢，我比较重视基础，平时对数据结构、 JDK 、 Spring 、 Mysql 这些研究的多一点，比如 JDK 的线程机制啊、ThreadLocal、各种集合类、并发的锁啊，Spring 的 IOC 机制，JVM 的一些东西、还有Mysql 的索引机制这些，因为像这些最基本的东西，你了解原理和不了解原理区别挺大的，比如一个集合类的选择错误或者一个不正确的数据库索引对性能的影响是挺大的。

然后我也有一些核心系统设计的经验，比如第一家公司电商后台的秒杀系统还有现在公司的风控的策略引擎。

平时呢也会用博客输出一些技术文章和其他人交流，也会去 Leecode 上刷一些题，大学的时候也是参加过蓝桥杯这种考察数据结构算法的比赛也是拿过奖。最近的话准备是在研究 Apache 新推出的 Spring Cloud Alibaba 这个东西，看能不能用在公司的微服务框架上去。



## 介绍一下风控项目

背景：P2P 理财=》国家限制标的金额=》如何消耗资金池=》小标贷款（信用卡待还、场景消费分期、现金贷）=》完善的贷前（反欺诈）、贷中（指标监控）、贷后（催收）的风控能力。

风控策略=》如何实现=》规则引擎、对用户信用建模（评分卡、交叉决策表）

我主要负责策略引擎的开发（基本能力），具体策略规则的开发和部署，以及一些支撑服务的研发（网关、计数、案件、管理后台），**网关服务主要是做风控的前置，由业务系统调用，用来做知识包路由、入参校验、异步、限流**，案件中心提供回溯和回归测试功能，计数服务提供灵活可配置的数据统计能力

![](https://kolly-imgstore.oss-cn-shenzhen.aliyuncs.com/img/金融风控平台.png)

### 限流是怎么做的

#### 常用的限流算法有两种：**漏桶算法**和**令牌桶算法**

对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。

用的是Guava RateLimiter，该类基于令牌桶算法实现流量限制，使用十分方便

- 具体怎么实现的？（要点是固定速率且令牌数有限）

  桶中的令牌是持续生成存放的，有请求时需要先从桶中拿到令牌才能开始执行，谁来持续生成令牌存放呢？一种解法是，开启一个定时任务，由定时任务持续生成令牌。这样的问题在于会极大的消耗系统资源。另一种解法则是延迟计算，如上 resync 函数。该函数会在每次获取令牌之前调用，其实现思路为，若当前时间晚于 nextFreeTicketMicros，则计算该段时间内可以生成多少令牌，将生成的令牌加入令牌桶中并更新数据。这样一来，只需要在获取令牌时计算一次即可。

- 如果突然很多线程同时请求令牌，有什么问题？（导致很多请求积压，线程阻塞）

- 怎么解决呢？（可以把积压的请求放到消息队列，然后异步处理）

- 如果不用消息队列怎么解决？（说了 RateLimiter 预消费的策略）

  只要当前时间大于可以获取令牌的时间，那么此次令牌获取的请求都能满足，不管是否桶里面有足够的令牌，会把预消费的令牌需要生成的时间加到下次可获取令牌的时间上，也就是下一个请求会为这次预消费买单

[印象笔记：Java | 系统架构 | 限流算法以及 Guava RateLimiter 的使用](https://app.yinxiang.com/fx/284a102a-1b84-493f-96cd-0bdf0d969318)

https://zhuanlan.zhihu.com/p/60979444

### 介绍一下规则引擎

“如果....那么....”形式表示的规则。而这种规则便称为产生式。而这正是产生式系统的基础

解决简单问题，只需一个产生式，而解决难题这需要多个产生式，而这些产生式的集合便是产生式系统

规则引擎是一个将业务决策从应用程序代码中分离出来，并使用预定义的语义模块编写业务决策的组件，它**接受数据输入**，**匹配业务规则**，并根据业务规则**做出业务决策**

JBoss Drools开源产品也只能说是半成品，如果真正想使用时需要做大量的二次开发工作的

### 介绍一下 Rete 算法

在一个产生式系统中，被处理的数据叫做working memory，用于判定的规则分为两个部分LHS（left-hand-side）和RHS（right hand side），分别表示前提和结论，主要流程可以分为以下步骤：
（1）Match：找出符合LHS部分的working memory集合
（2）Confilict resolution：选出一个条件被满足的规则
（3）Act：执行RHS的内容
（4）返回1  

RETE算法主要改进Match的处理过程，通过构建一个网络进行匹配

其核心思想是将分离的匹配项根据内容动态构造匹配树，以达到显著降低计算量的效果，同时缓存中间结果。以空间换时间

### 计数服务

计算方式：自然（日、天）、非自然（日、天）、历史

redis key存储：yyMMddHHmm、yyMMddHH、yyMMdd、history

计数类型：累加（count）—— hash、关联（relate）—— set、基数（ip、uv）——hyperloglog



## 介绍一下 Spring Cloud 项目

背景：技术转型 DubboX =》Spring Cloud （ JMF 弃用、php 全部转 Java，前端方便 Eureka 接入）

1> starter 项目，简化依赖、公共逻辑抽离、规范约定、统一处理（配置、异常、日志上报）

2> 项目结构规范、脚手架（app-rest、app-mq、app-job、business、common）

#### 用了 Spring Cloud 哪些组件

注册中心 Eureka、Feign

其他：Apollo、RabbitMQ、Spring Boot Admin、XXL-JOB、Mybatis-Plus

#### Spring Cloud 和 Dubbo 的区别

Dubbo 基于RPC，Spring Cloud 基于 Rest Api

Dubbo只是实现了服务治理

Spring Cloud下面有17个子项目（可能还会新增）分别覆盖了微服务架构下的方方面面

Dubbo 的框架本身，无处不体现对性能的极致追求：网络使用 netty 框架、自定义网络传输协议、不使用原生的反射而是基于 javassist 动态生成代码、线程模型、二进制序列化Hession

#### Spring Cloud 服务调用方式为什么使用 http restful 而不是RPC？

HTTP Restful 本身**轻量，易用**，适用性强，可以很容易的**跨语言，跨平台**，或者**与已有系统交互**

各类 RPC 协议本身有各自的使用范围和编码要求，这些会对交互两端的代码形成约束，服务提供方与调用方接口依赖方式太强

rpc 可以实现高性能

#### 还知道哪些 RPC 框架

grpc：Google 出品，基于ProtoBuf序列化协议（Google 内部服务都是这个协议），文档和案例更丰富，生成的代码更少更干净

thrift：Twitter 出品，支持的语言更多



## 介绍一下商城项目

背景：两三百个公众号=》五六百万粉丝=》自建商城（商家供货）

负责商品模块、订单模块、支付模块的设计，秒杀系统的设计

### 系统之间怎么交互的

用户模块、商品模块、订单模块、支付模块

![](https://kolly-imgstore.oss-cn-shenzhen.aliyuncs.com/img/商城模块交互图.png)

### 商品模块怎么设计的

#### 商品分类

二级分类（服装->外套、数码->手机）

#### 商品类型

##### 属性(颜色、尺码、容量)

属性选择类型：0->唯一；1->单选；2->多选

属性录入方式：0->手工录入；1->从列表中选取

可选值列表，以逗号隔开

排序字段：最高的可以单独上传图片

参数（屏幕尺寸、电池容量、网络）

#### 商品

商品分类、商品类型、库存、预警库存

#### 商品 SKU

sku编码、库存、预警库存、锁定库存、规格属性1、规格属性2、规格属性3、图片（不是每个 sku 都有）

### 订单模块怎么设计的

#### 订单表

订单 id，会员 id，优惠券 id，订单编号，订单总金额，应付金额，订单状态

促销优化金额（促销价、满减、阶梯价），优惠券抵扣金额，积分抵扣金额，

#### 订单商品表

> 订单中包含的商品信息，一个订单中会有多个订单商品信息

订单编号，商品 id，sku 编号，销售价格，购买数量
sp1，sp2，sp3，商品销售属性:[{"key":"颜色","value":"颜色"},{"key":"容量","value":"4G"}]
商品促销名称，商品促销分解金额，优惠券优惠分解金额，积分优惠分解金额，该商品经过优惠后的分解金额
商品赠送积分，商品赠送成长值

#### 订单操作记录表

当订单状态发生改变时，用于记录订单的操作信息。

#### 购物车表

用于存储购物车中每个商品信息，可用于计算商品优惠金额

#### 关键流程：加入购物车 & 查看购物车列表

> 购物车的主要功能就是存储用户选择的商品信息及计算购物车中商品的优惠

- 先根据productId对CartItem进行分组，以spu为单位进行计算优惠
  - 由于商品优惠都是以商品为单位来设计的，并不是以sku为单位设计的，所以必须以商品为单位来计算商品优惠
- 查询所有商品的优惠相关信息
- 根据商品促销类型(单品促销、阶梯价格、满减)计算商品促销优惠价格

#### 关键流程：生成确认单

> 确认单主要用于用户确认下单的商品信息、优惠信息、价格信息，以及选择收货地址、选择优惠券和使用积分

- 获取优惠券信息（展示）
- 判断每个优惠券是否可用（全场通用、指定分类、指定商品）
- 获取积分以及积分规则（展示）
- 总金额的计算：购物车中所有商品的总价
- 活动优惠的计算：购物车中所有商品的优惠金额累加（促销、满减、折扣）
- 应付金额的计算：应付金额 = 总金额 - 活动优惠

#### 关键流程：下单

> 对购物车中信息进行处理，综合下单用户的信息来生成订单。

- 库存锁定（sku 表的锁定库存字段 + 1，行锁）
- 判断是否使用了优惠券 -> 优惠券分解金额(对商品均摊) -> 修改优惠券的使用状态
- 判断是否使用了积分 -> 扣除积分 -> 抵扣金额
- 订单中每个商品的实际支付金额计算：原价-促销优惠-优惠券抵扣-积分抵扣，促销优惠就是购物车计算优惠流程中计算出来的优惠金额
- 生成订单号
- 删除购物车商品
- 调用支付接口生成预支付订单返回给前端

### 支付模块

微信支付、统一下单、支付回调（步长）

### 用户模块

分表、积分、会员

### 秒杀系统怎么设计的(2W+QPS)

1. 可能的瓶颈：nginx、redis、数据库、Java 内存（机器扩容）
2. 防刷（sadd 入队排重）
3. 超卖（数据库行锁）

mysql 的 innodb 引擎行锁机制下，update 的 sql 到了数据库就开始排队，期间数据库连接是被占用的，当请求足够多时就会造成数据库的拥堵

#### 前端

静态页面走CDN

前端轮询接口查看活动状态，已结束的话按钮置灰不允许发送请求

产品层面，点击按钮提交后按钮置灰禁止重复提交；JS层面，限制用户在x秒之内只能提交一次请求

#### 数据库读写分离减少数据库连接的占用

master 写 binary log、slave 拷贝 binary log 到 relay log（IO 线程）、slave 重做 relay log中的事件（SQL 线程）

#### nginx 限制一部分请求进入后端
如果后台接口稳定 100ms 内返回，nginx 并发 4-5 万没问题

如果 nginx 成为瓶颈（十万级并发），可以使用阿里 SLB + nginx 集群解决（或者 LVS：linux visual server）

SLB（Server Load Balance）服务通过设置虚拟服务地址（IP），将位于同一地域（Region）的多台云服务器（Elastic Compute Service，简称ECS）资源虚拟成一个高性能、高可用的应用服务池；再根据应用指定的方式，将来自客户端的网络请求分发到云服务器池中。

#### tomcat 线程池

maxThreads - 池中最大线程数 maxQueueSize - 

#### 判断活动是否结束（性能瓶颈）

起止时间 + 活动状态判断，状态存储在 redis，多机部署不能放在内存（不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的）

如果 redis 读取到状态为已结束，将结果缓存到Java 内存中，避免 redis 被频繁访问

#### 排队进入队列（队列长度 = 120 % * 秒杀商品数）

redis set 实现队列，用户 Id 作为 key，scard >= limit 入队失败，否则 sadd 入队，sadd 返回 0，重复请求直接返回，sadd 返回 1，入队成功，去数据库扣库存

#### 执行 update sql 判断下单成功与否，成功后异步生成订单

update t_sku set remain = remain - 1 where sku_id = xx and remain > 0；

有人没抢到就设置活动结束

#### 如果有人成功下单，但是不支付呢？

订单取消后，设置状态为未结束，用户出队列

#### 如何防刷？同一个用户 N 次请求

### 优惠券怎么设计的

#### 优惠券表

优惠券的使用类型：0->全场通用；1->指定分类；2->指定商品

#### 优惠券历史记录表

当会员领取到优惠券时，会产生一条优惠券的记录，需要注意的是它的使用状态：0->未使用；1->已使用；2->已过期

#### 优惠券和商品的关系表

当优惠券类型为指定商品时，用此表维护商品 ID 与优惠券 ID 的映射关系

#### 优惠券和商品分类关系表

当优惠券类型为指定分类时，用此表维护商品分类 ID 与优惠券 ID 的映射关系

### Redis怎么用的

#### 手机验证码

set、expire、get

#### 分布式锁

```java
// 加锁代码
String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);

if ("OK".equals(result)) {
		return true;
}
return false;
```

```java
// 解锁代码
String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));

if (1L.equals(result)) {
		return true;
}
return false;
```

#### 订单号生成

全局唯一 ID生成办法：单点 Redis 自增、美团 Leaf 算法、Twitter snowflake算法



### RabbitMQ 怎么用的

用户下单后**发送延时消息** -> 订单超时取消 

定时任务，补偿机制保证最终一致性
