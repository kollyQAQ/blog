[TOC]

## 存储引擎

### InnoDB

是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升

### MyISAM

设计简单，数据以紧密格式存储。对于**只读数据**，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括**压缩表**、**空间数据索引**等

不支持外键；不支持事务；不支持行级锁，只能对整张表加锁

## Mysql 索引

### 哈希索引

对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择 BTree 索引。

### B+ Tree 的原理

**B+ Tree 索引**是大多数 MySQL 存储引擎的默认索引类型

![B树](/Users/kolly/Library/Application Support/typora-user-images/image-20190824154242369.png)

![B+树](/Users/kolly/Library/Application Support/typora-user-images/image-20190824154317494.png)

### 为什么MySQL的索引要使用B+树，而不是其它树？比如B树？

1. 因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少。指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低。

2. B+ 树的叶子节点链表结构相比于 B- 树便于扫库和范围检索。

### 索引的分类

#### 主键索引

**主键索引的叶子节点存的是整行数据**。在 InnoDB 里，**主键索引也被称为聚簇索引**

#### 普通索引

这是最基本的索引，它没有任何限制，默认的BTREE类型的索引。

**非主键索引的叶子节点内容是主键的值**。在 InnoDB 里，非主键索引也被称为**二级索引**

#### 唯一索引

与普通索引类似，不同的就是：索引列的值必须唯一，**但允许有空值**（注意和主键不同）。如果是组合索引，则列值的组合必须唯一

#### 全文索引

用于查找文本中的关键词，而不是直接比较是否相等

#### 单列索引、组合索引（最左前缀）

多个单列索引与单个多列索引（组合索引）的查询效果不同，因为执行查询时，**MySQL只能使用一个索引**，会从多个索引中选择一个限制最为严格的索引

平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如建立一个组合索引：`ALTER TABLE t_user ADD INDEX index_union (userId,mobile,age)；`。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：

```xml
- 建立一个组合索引
ALTER TABLE t_user ADD INDEX index_union (`userId`,`mobile`,`age`)；

- 选择 explain 查看执行计划来观察索引利用情况
查询条件为 userid —— 组合索引有效
EXPLAIN SELECT * FROM `t_user` WHERE userid='10010'
```

组合索引**有效**的情况

- 查询条件为 **userid**、查询条件为 **userid and mobile**
- 查询条件为 **mobile and userid**（调换了查询条件的顺序，发现联合索引依旧**有效**）
- 查询条件为 **userid and age**（位于索引位置的**第一和第三**，联合索引依旧**有效**！）
- 查询条件为 **userid and mobile and age**（**有效**！当然，这才是最正统的用法）

组合索引**无效**的情况

- 查询条件为 **mobile**、查询条件为 **age**
- 查询条件为 **userid or mobile**（把 `and` 换成 `or`，发现联合所索引**无效**！）
- 查询条件为 **mobile and age**（位于索引位置的**第二和第三**，联合索引**无效**！）

### 索引的优化

索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但**如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快**。索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句

#### 索引不会包含有NULL值的列

只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为 NULL

#### 使用前缀索引

对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个 CHAR(255) 的列，如果在前 10 个或 20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和 I/O 操作。对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引

#### 索引列排序

**让选择性最强的索引列放在前面**。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1

**MySQL查询只使用一个索引**，因此如果 where 子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；**尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引**

#### like语句操作

一般情况下不鼓励使用 like 操作，如果非使用不可，如何使用也是一个问题。**like “%aaa%” 不会使用索引而like “aaa%”可以使用索引**

#### 不要在列上进行运算

例如：select * from users where YEAR(adddate) < 2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select * from users where adddate < ’2007-01-01′

#### 索引覆盖

**覆盖索引**：SQL 只需要通过索引就可以返回查询所需要的数据，而不必通过二级索引查到主键之后再去查询数据

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称 之为 “覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键 + 列值。最终还是要 “回表”，也就是要通过主键再查找一次，这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作

#### 删除长期未使用的索引

不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用

#### 最后总结一下

MySQL只对以下操作符才使用索引：<, <=, =, >, >=, between, in 以及某些时候的 like (不以通配符%或_开头的情形)



## Mysql 性能调优

### 索引优化

### 使用 Explain 进行分析

### 优化数据访问

- 只返回必要的列：最好不要使用 SELECT * 语句
- 只返回必要的行：使用 LIMIT 语句来限制返回的数据
- 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的

### 重构查询方式

#### 切分大查询

一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询

#### 分解大连接查询

将一个大连接查询分解成对每一个表进行一次单表查询，然后**在应用程序中进行关联**



## 乐观锁、悲观锁

### 悲观锁 

https://chenzhou123520.iteye.com/blog/1860954

我们使用了 **select…for update** 的方式，这样就通过数据库实现了悲观锁。此时在 t_goods 表中，id 为 1 的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。

注：需要注意的是，在事务中，只有 SELECT ... FOR UPDATE 或 LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般 SELECT ... 则不受此影响。拿上面的实例来说，当我执行 select status from t_goods where id=1 for update; 后。我在另外的事务中如果再次执行 select status from t_goods where id=1 for update; 则第二个事务会一直等待第一个事务的提交，此时第二个查询处于阻塞的状态，但是如果我是在第二个事务中执行 select status from t_goods where id=1; 则能正常查询出数据，不会受第一个事务的影响。

使用 select…for update 会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB 默认 Row-Level Lock，所以只有「明确」地指定主键，MySQL 才会执行 Row lock (只锁住被选取的数据) ，否则 MySQL 将会执行 Table Lock (将整个数据表单给锁住)。

### 乐观锁 

https://chenzhou123520.iteye.com/blog/1863407

1. 使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式
2. 乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的 table 中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的 version 类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突（使用 updateTime，可以不用手动维护）



## 主从复制

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

- **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。（binlog格式：statment row mixed）
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- **SQL 线程** ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png)

### 主从同步的延时问题解决

1.	在数据库和应用层增加缓存处理，优先从缓存中读取数据
2.	减少slave同步延迟，可以修改slave库sync_binlog属性 
- sync_binlog=0：文件系统来调度把binlog_cache刷新到磁盘，性能好，一致性差
- sync_binlog=n：n次commit后刷新cache到磁盘，越小一致性越好，性能越差



## 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，可以是应用层代理，也可以是通过代理服务器（中间件）接收应用层传来的读写请求，然后决定转发到哪个服务器。

应用层配置多数据源，AOP切面选择数据源（Mytis-Plus 注解）

中间件：Mycat


![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png)
