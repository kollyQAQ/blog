

[TOC]

## Redis

### redis的常见数据类型及应用场景

string、list、hash、set

zset（排行榜）
- zadd key score member
- zrange key start stop 【withscores】

hyperloglog（uv）
- pfadd key value [value...]
- pfcount key
- 特点：比较准确的估算出你要统计的数量，但是却无法知道统计的详细内容；即使输入元素的数量或者体积非常非常大，计算基数（大概值）所需的空间总是固定的、并且是很小的；bitmap？

### 如何访问 redis 中的海量数据（keys 和 scan的比较）

keys 遍历，O(n)复杂度，单线程，如果 key 过多执行时间过长导致服务假死，**生产环境禁止使用**

scan ，O(n)复杂度，通过游标分步骤进行，不会阻塞线程，**返回结果可能重复，需要客户端去重**

scan cursor [MATCH pattern] [COUNT count]   count - 扫描的数据量

### 持久化

#### RDB 持久化
使用fork函数复制一份当前进程的副本(子进程)（性能好，一致性差）

将某个时间点的所有数据都存放到硬盘上，可以将快照复制到其它服务器从而创建具有相同数据的服务器副本

如果系统发生故障，将会丢失最后一次创建快照之后的数据；如果数据量很大，保存快照的时间会很长

#### AOF 持久化
记录每一条写命令添加到 AOF 文件（Append Only File）的末尾（性能差，一致性好）

需要设置同步选项：always - 每个写命令都同步（性能极差） everysec - 每秒同步一次（常用）

### redis 内存淘汰机制

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略

volatile-lru（最近最少使用的数据淘汰）、allkeys-lru

volatile-ttl（将要过期的数据淘汰）

volatile-random（任意随机选择数据淘汰）、allkeys-random

### redis是单线程为什么还这么快

Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。

1、完全基于内存，绝大部分请求是纯粹的内存操做

2、数据结构简单，对数据操作也简单

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路 I/O 复用模型，非阻塞IO。**这里 “多路” 指的是多个网络连接，“复用” 指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗）

### 事务

使用 MULTI 和 EXEC 命令将事务操作包围起来。MULTI 去开启事务，EXEC 去执行事务

Lua脚本支持（减少网络开销、原子性、复用）

### 集群

#### 哨兵机制 sentinel

1.  监控master和salve是否正常运行

2.  如果master出现故障，那么会把其中一台salve数据升级为master

## rabbitMQ

### 交换机的类型

- 扇形交换机：Fanout exchange

  扇形交换机是最基本的交换机类型，它所能做的事情非常简单———广播消息。扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。

- 直连交换机：Direct exchange

  直连交换机是一种带路由功能的交换机，一个队列会和一个交换机绑定，除此之外再绑定一个`routing_key`，当消息被发送的时候，需要指定一个`binding_key`，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个`binding_key`也是支持应用到多个队列中的

  **适用场景**：有优先级的任务，根据任务的优先级把消息发送到对应的队列，**这样可以指派更多的资源去处理高优先级的队列**

- 主题交换机：Topic exchange

  - ![](https://kolly-imgstore.oss-cn-shenzhen.aliyuncs.com/img/rabbitmq 主题交换机.png)
  - https://www.jianshu.com/p/469f4608ce5d

- 首部交换机：Headers exchange

  首部交换机是忽略`routing_key`的一种路由方式。路由器和交换机路由的规则是通过`Headers`信息来交换的，这个有点像`HTTP`的`Headers`。将一个交换机声明成首部交换机，绑定一个队列的时候，定义一个`Hash`的数据结构，消息发送的时候，会携带一组hash数据结构的信息，当`Hash`的内容匹配上的时候，消息就会被写入队列。

  绑定**交换机**和**队列**的时候，Hash结构中要求携带一个键**“x-match”**，这个键的`Value`可以是`any`或者`all`，这代表消息携带的`Hash`是需要**全部匹配**(all)，还是**仅匹配一个键**(any)就可以了。相比直连交换机，首部交换机的优势是匹配的规则**不被**限定为字符串(string)。

### RabbitMQ 的高可用性如何保证?

镜像集群模式

### RabbitMQ如何保证不丢数据

**生产端**：开启 confirm 模式，你每次写的消息都会分配一个唯一的 id，然后如果写入了RabbitMQ 中，RabbitMQ 会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，你可以重试

**队列本身**：创建 queue 的时候将其设置为**持久化**；发送消息的时候将消息的 deliveryMode 设置为 2，就是将消息设置为**持久化**的

**消费端**：用RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，通过自己的一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的

### 如何保证队列的消息不被重复消费？

这个需要灵活作答，考察的是思考力，因为消费的场景有很多，有数据库、有缓存、有第三方接口

- 1.比如针对数据库，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键（或者UUID），那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。
- 2.再比如redis缓存，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算**幂等操作**。
- 3.再比如第三方接口，需要确定两点，第三方接口程序是有去重能力的（取消订单），那么脏一点直接丢数据过去，如果没有去重能力，还是需要我们来写程序去重，就是第2点的办法。

### RabbitMQ一样，如何保证消息被消费，突然节点宕机怎么办

保证高可用、做好持久化、开启 ack 机制

### 消息丢失怎么办

- 保证他不要丢失（见上面）

- 通过补偿机制实现最终一致性，取消订单逻辑有定时任务做补偿



## MongoDB

### 优点

#### No Schema，JSON 格式存储

最接近真实对象模型，对开发者友好，增加字段不用修改表结构，方便快速开发迭代 ========> 三方征信系统

#### 强大的索引支持

**地理位置索引**构建各种 O2O 应用，**文本索引**解决搜索问题、**TTL 索引**解决自动过期的需求=========> 查找附近的人、地点

#### 解决数据分析场景需求

### 缺点

#### 不支持事务



## Zookeeper

[zookeeper 都有哪些使用场景？](https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/zookeeper-application-scenarios.md)

[面试最常见问题之 zookeepe](https://xiaozhuanlan.com/topic/1057284396)

### 分布式协调

这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上**对某个节点的值注册个监听器**，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。

### HA高可用性

这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个**重要进程一般会做主备**两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。

### 元数据/配置信息管理

zookeeper 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zookeeper 么？

### 分布式锁

举个栗子。对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也**尝试去创建**那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。