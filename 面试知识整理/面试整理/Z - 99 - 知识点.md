## SKU 和 SPU 的 区别

SKU(Stock Keeping Unit)是指库存量单位，SPU(Standard Product Unit)是指标准产品单位。举个例子：iphone x是一个SPU，而iphone x 港版 64G 银色是一个SKU



## 端口
nginx 80 | tomcat 8080 | mysql  3306 | redis  6379 | Zookeeper  2181 | kafka  9092 | rabbitMQ  xxx




## 常用攻击技术

跨站脚本攻击（Cross-Site Scripting, XSS）

跨站请求伪造（Cross-site request forgery，CSRF）

SQL 注入攻击

DDOS



## 网络

### 浏览器输入 URL 发生了什么？TCP 和 UDP 区别？TCP 如何保证传输可靠性？

1. DNS 解析
2. TCP 连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 连接结束

### TCP 三次握手

- 客户端——发送带有 SYN 标志的数据包——一次握手——服务端
- 服务端——发送带有 SYN/ACK 标志的数据包——二次握手——客户端
- 客户端——发送带有带有 ACK 标志的数据包——三次握手——服务端

#### 为什么要传回 SYN

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了

#### 传了 SYN,为啥还要传 ACK

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证

### TCP 四次挥手

- 客户端——发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器——收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器——关闭与客户端的连接，发送一个FIN给客户端
- 客户端——发回 ACK 报文确认，并将确认序号设置为收到序号加1

#### 为什么要四次挥手

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接

三次握手是第二次的时候  ACK 和 SYN 一起发，四次挥手是因为发送 ACK 后可能还会有数据要发送，发送完毕后再发送 FIN 信号，所以 ACK 和 FIN 是分两次的，整个过程多一次

**三次握手四次挥手详细解析：**https://blog.csdn.net/qzcsu/article/details/72861891

### HTTPS 原理

HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。

HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

- 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
- 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

### HTTP长连接、短连接究竟是什么？

#### **1. HTTP 协议与 TCP/IP 协议的关系**

HTTP 的长连接和短连接本质上是 TCP 长连接和短连接。HTTP 属于应用层协议，在传输层使用 TCP 协议，在网络层使用 IP 协议。 IP 协议主要解决网络路由和寻址问题，TCP 协议主要解决如何在 IP 层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP 协议是可靠的、面向连接的。

#### 2. 如何理解 HTTP 协议是无状态的

HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。

#### 3. 什么是长连接、短连接？

在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。

而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。

https://www.cnblogs.com/gotodsp/p/6366163.html

## Spring 事务的传播行为 Propagation

**支持当前事务的情况：**

- TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

**不支持当前事务的情况：**

- TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
  - A 类的某个方法 m1 中调用 B 类的某个方法 m2 后执行 m1 中的其他代码时出异常了，导致 m2 的数据库操作也没有提交，如果想让 m2 不受影响可以设置 m2 方法的事务级别为 REQUIRES_NEW 来解决
- TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。

**其他情况：**

- TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。

**注意：在默认的代理模式下，只有目标方法由外部调用，才能被 Spring 的事务拦截器拦截。在同一个类中的两个方法直接调用，是不会被 Spring 的事务拦截器拦截**（可以使用 AspectJ 取代 Spring AOP 代理来解决这个问题）



## 事务的隔离级别 Isolation

- Isolation.READ_UNCOMMITTED 未提交读
  - 事务中的修改，即使没有提交，对其它事务也是可见的
- Isolation.READ_COMMITTED 提交读
  - Sql Server , Oracle 的默认值
  - 一个事务只能读取已经提交的事务所做的修改。换句话说，**一个事务所做的修改在提交之前对其它事务是不可见的**
- Isolation.REPEATABLE_READ 可重复读
  - Mysql 的默认值
  - **保证在同一个事务中多次读取同样数据的结果是一样的**
- Isolation.SERIALIZABLE 可串行化
  - 强制事务串行执行
- 脏读
  - T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据
- 不可重复读
  - T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同
- 幻影读
  - T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取（和第一次读在一个事务中）这个范围的数据，此时读取的结果和和第一次读取的结果不同

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| -------- | ---- | ---------- | ------ |
| 未提交读 | √    | √          | √      |
| 提交读   | ×    | √          | √      |
| 可重复读 | ×    | ×          | √      |
| 可串行化 | ×    | ×          | ×      |

## 分布式相关
### 缓存问题
#### 缓存穿透
指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库

解决方案：

- 对这些不存在的数据缓存一个空数据；
- 对这类请求进行过滤。（布隆过滤器）

有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被 这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

#### 缓存雪崩

我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩

解决方案：

- 过期时间设置不要集中（在原有的失效时间基础上增加一个随机值）

#### 缓存击穿

缓存在某个时间点过期的时候，恰好在这个时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮

解决方案：

- 使用互斥锁 (mutex key)

业界比较常用的做法，是使用 mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX 或者 Memcache 的 ADD）去 set 一个 mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法

```java
public String get(key) {
      String value = redis.get(key);
      if (value == null) { //代表缓存值过期
          //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
          if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
            	value = db.get(key); // 从数据库 load 数据
            	redis.set(key, value, expire_secs);
            	redis.del(key_mutex);
          } else {
		          //这个时候代表同时候已经有其他线程正在load db并回设到缓存了，这时候重试获取缓存值即可
            	sleep(50);
            	get(key);  //重试
          }
      } else {
        	return value;      
      }
}
```



#### Java为什么不支持多重继承

考虑一个类 A 有 foo() 方法, 然后 B 和 C 派生自 A, 并且有自己的 foo() 实现，现在 D 类使用多个继承派生自 B 和C，如果我们只引用 foo(), 编译器将无法决定它应该调用哪个 foo()

#### String为什么设计为不可变类